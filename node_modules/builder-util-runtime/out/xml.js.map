{"version":3,"sources":["../src/xml.ts"],"names":[],"mappings":"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","sourcesContent":["import * as sax from \"sax\"\nimport { newError } from \"./index\"\n\nexport class XElement {\n  value = \"\"\n  attributes: { [key: string]: string } | null = null\n  isCData = false\n  elements: Array<XElement> | null = null\n\n  constructor(readonly name: string) {\n    if (!name) {\n      throw newError(\"Element name cannot be empty\", \"ERR_XML_ELEMENT_NAME_EMPTY\")\n    }\n    if (!isValidName(name)) {\n      throw newError(`Invalid element name: ${name}`, \"ERR_XML_ELEMENT_INVALID_NAME\")\n    }\n  }\n\n  attribute(name: string): string {\n    const result = this.attributes === null ? null : this.attributes[name]\n    if (result == null) {\n      throw newError(`No attribute \"${name}\"`, \"ERR_XML_MISSED_ATTRIBUTE\")\n    }\n    return result\n  }\n\n  removeAttribute(name: string): void {\n    if (this.attributes !== null) {\n      delete this.attributes[name]\n    }\n  }\n\n  element(name: string, ignoreCase = false, errorIfMissed: string | null = null): XElement {\n    const result = this.elementOrNull(name, ignoreCase)\n    if (result === null) {\n      throw newError(errorIfMissed || `No element \"${name}\"`, \"ERR_XML_MISSED_ELEMENT\")\n    }\n    return result\n  }\n\n  elementOrNull(name: string, ignoreCase = false): XElement | null {\n    if (this.elements === null) {\n      return null\n    }\n\n    for (const element of this.elements) {\n      if (isNameEquals(element, name, ignoreCase)) {\n        return element\n      }\n    }\n\n    return null\n  }\n\n  getElements(name: string, ignoreCase = false) {\n    if (this.elements === null) {\n      return []\n    }\n    return this.elements.filter(it => isNameEquals(it, name, ignoreCase))\n  }\n\n  elementValueOrEmpty(name: string, ignoreCase = false): string {\n    const element = this.elementOrNull(name, ignoreCase)\n    return element === null ? \"\" : element.value\n  }\n}\n\nconst NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i)\n\nfunction isValidName(name: string) {\n  return (NAME_REG_EXP.test(name))\n}\n\nfunction isNameEquals(element: XElement, name: string, ignoreCase: boolean) {\n  const elementName = element.name\n  return elementName === name || (ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase())\n}\n\nexport function parseXml(data: string): XElement {\n  let rootElement: XElement | null = null\n  const parser = sax.parser(true, {})\n  const elements: Array<XElement> = []\n\n  parser.onopentag = saxElement => {\n    const element = new XElement(saxElement.name)\n    element.attributes = saxElement.attributes as { [key: string]: string }\n\n    if (rootElement === null) {\n      rootElement = element\n    }\n    else {\n      const parent = elements[elements.length - 1]\n      if (parent.elements == null) {\n        parent.elements = []\n      }\n      parent.elements.push(element)\n    }\n    elements.push(element)\n  }\n\n  parser.onclosetag = () => {\n    elements.pop()\n  }\n\n  parser.ontext = text => {\n    if (elements.length > 0) {\n      elements[elements.length - 1].value = text\n    }\n  }\n\n  parser.oncdata = cdata => {\n    const element = elements[elements.length - 1]\n    element.value = cdata\n    element.isCData = true\n  }\n\n  parser.onerror = err => {\n    throw err\n  }\n\n  parser.write(data)\n  return rootElement!!\n}"],"sourceRoot":""}

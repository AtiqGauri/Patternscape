{"version":3,"sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEM,SAAU,iBAAV,CAA4B,KAA5B,EAAwC;AAC5C,EAAA,OAAO,CAAC,KAAR,CAAc,iBAAM,GAAN,CAAU,CAAC,KAAK,CAAC,KAAN,IAAe,KAAhB,EAAuB,QAAvB,EAAV,CAAd;AACA,EAAA,OAAO,CAAC,IAAR,CAAa,CAAb;AACD,C,CAED;;;AACO,eAAe,cAAf,CAAiC,OAAjC,EAAsD,IAAtD,EAAsG;AAC3G,MAAI,MAAM,GAAa,IAAvB;;AACA,MAAI;AACF,IAAA,MAAM,GAAG,MAAM,OAAf;AACD,GAFD,CAGA,OAAO,aAAP,EAAsB;AACpB,QAAI;AACF,YAAM,IAAI,CAAC,IAAD,CAAV;AACD,KAFD,CAGA,OAAO,SAAP,EAAkB;AAChB,YAAM,IAAI,WAAJ,CAAgB,CAAC,aAAD,EAAgB,SAAhB,CAAhB,CAAN;AACD;;AAED,UAAM,aAAN;AACD;;AAED,QAAM,IAAI,CAAC,KAAD,CAAV;AACA,SAAO,MAAP;AACD;;AAEK,MAAO,WAAP,SAA2B,KAA3B,CAAgC;AACpC,EAAA,WAAA,CAAY,MAAZ,EAAkC,OAAA,GAAkB,kBAApD,EAAsE;AACpE,QAAI,CAAC,GAAG,OAAR;AACA,QAAI,CAAC,GAAG,CAAR;;AACA,SAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;AAC1B,YAAM,MAAM,GAAG,UAAU,CAAC,EAAE,GAA5B;AACA,MAAA,CAAC,IAAI,SAAS,MAAT,GAAkB,IAAI,MAAJ,CAAW,EAAX,CAAlB,GAAmC,IAAnC,GAA0C,KAAM,CAAC,KAAtD;AACD;;AACD,UAAM,CAAN;AACD;;AATmC;;;;AAYhC,SAAU,oBAAV,CAAkC,OAAlC,EAAqD;AACzD,SAAO,gBAAgB,CAAC,OAAD,EAAU,IAAV,CAAvB;AACD;;AAEK,SAAU,gBAAV,CAA8B,OAA9B,EAAmD,aAAnD,EAAmE;AACvE,SAAO,OAAO,CACX,KADI,CACE,CAAC,IAAG;AACT,QAAI,CAAC,CAAC,IAAF,KAAW,QAAX,IAAuB,CAAC,CAAC,IAAF,KAAW,SAAtC,EAAiD;AAC/C,aAAO,aAAP;AACD;;AACD,UAAM,CAAN;AACD,GANI,CAAP;AAOD,C","sourcesContent":["import chalk from \"chalk\"\n\nexport function printErrorAndExit(error: Error) {\n  console.error(chalk.red((error.stack || error).toString()))\n  process.exit(1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (isErrorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  await task(false)\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (const error of errors) {\n      const prefix = `Error #${i++} `\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function orNullIfFileNotExist<T>(promise: Promise<T>): Promise<T | null> {\n  return orIfFileNotExist(promise, null)\n}\n\nexport function orIfFileNotExist<T>(promise: Promise<T>, fallbackValue: T): Promise<T> {\n  return promise\n    .catch(e => {\n      if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n        return fallbackValue\n      }\n      throw e\n    })\n}"],"sourceRoot":""}
